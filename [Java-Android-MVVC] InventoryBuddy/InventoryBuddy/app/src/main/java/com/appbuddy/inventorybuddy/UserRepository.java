// :core:data module UserRepository.java
package com.appbuddy.inventorybuddy;

import android.content.SharedPreferences;
import android.util.Log;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.inject.Inject;
import javax.inject.Singleton;

// Repository: ViewModel API for data operations
// Centralized SSOT (Single Source of Truth) for data from 0 to many data sources/DAOs
@Singleton  // Hilt annotation to ensure only 1 instance of this class
public class UserRepository {
    // attributes
    private final UserDao userDao;
    private final SharedPreferences sharedPreferences;  // stores key-value pairs
    private UserState userState = getUserState();
    private final ExecutorService dbExecutor = Executors.newCachedThreadPool();  // for background database operations
    private Long id;  // user id
//==================================================================================================
// Constructors
//==================================================================================================
    // public UserRepository() {}  // constructor unnecessary since using @Inject annotation for Hilt
    @Inject
    public UserRepository(UserDao userDao, SharedPreferences sharedPreferences) {
        this.userDao = userDao;
        this.sharedPreferences = sharedPreferences;
    }
//==================================================================================================
//  Custom Functions
//==================================================================================================
    /**
     * Called when user activates "Submit" button.
     * Existing user logs in if username and password are correct.
     * Otherwise, calls sign up function.
     *
     * @param username entered by user
     * @param password entered by user
     */
    // TODO: create transaction for login and sign up process to ensure atomicity and data integrity
    public void loginUser(String username, String password) {
        Callable<Long> loginCallable = () -> {
            // @Query returns null if record not found; otherwise returns id of matching row
            return getUserId(username ,password);
        };

        //dbExecutor.execute(() -> {  // background thread (asynchronous task)
        Future<Long> futureResult = dbExecutor.submit(loginCallable);  // submit task to ExecutorService
        try {
            id = futureResult.get();

            if (id == null) {  // account not found
                userState = UserState.LOGIN_FAILURE;
            } else {  // matching account found
                userState = UserState.LOGIN_SUCCESS;
                saveId(id);  // save id to SharedPreferences for future use
            }

        } catch (Exception e) {
            userState = UserState.ERROR_STATE;
            Log.e("UserRepository: loginUser: ", "userState = " + e);
        }
        //});

        try {
            setUserState(userState);  // so ViewModel can update toastMessage LiveData for View to observe
        } catch (Exception e) {
            Log.e("UserRepository: loginUser: ", "setUserState: " + e);
        }
    }
//==================================================================================================
    /**
     * Called when user activates "Submit" button on LoginFragment.
     * If account does not exist, account sign up is attempted.
     * @param username entered by user
     * @param password entered by user
     */
    public void signUpUser(String username, String password) {
        // TODO: implement Kotlin Coroutines for asynchronous (background) tasks for database/network operations
        Callable<Long> signUpCallable = () -> {
            User newUser = new User(username, password);  // create User instance
            // @Insert returns id of newly created row; otherwise -1L or -1 if username already exists (due to OnConflictStrategy.IGNORE)
            id = userDao.insertUser(newUser);  // get id of newly created user (or -1L if user already exists
            return id;
        };

        Future<Long> futureResult = dbExecutor.submit(signUpCallable);  // submit task to ExecutorService

        try {
        //dbExecutor.execute(() -> {
            id = futureResult.get();  // -1L or -1 if user already exists (due to OnConflictStrategy.IGNORE)

            //noinspection ConstantValue
            if (id > 0L || id > 0) {  // autogenerated id will always be 1 or greater when successful
                saveId(id);  // save id to SharedPreferences for future use
                loginUser(username, password);
                userState = UserState.SIGNUP_SUCCESS;
                setUserState(userState);
            } else {
                userState = UserState.SIGNUP_FAILURE;
                setUserState(userState);
            }
        } catch (Exception e) {  // account creation failed
            userState = UserState.ERROR_STATE;
            setUserState(userState);
            Log.e("UserRepository: signUpUser: ", (userState).toString() + e);
        }
        //});
    }
//==================================================================================================
//  Getters & Setters
//==================================================================================================
    public UserState getUserState() {
        return userState;
    }
    public void setUserState(UserState userState) {
        this.userState = userState;
    }
    public Long getUserId(String username, String password) {
        try {
            id = userDao.getUserId(username, password);
        } catch (Exception e) {
            Log.e("UserRepository: getUserId: ", "getUserId call: " + e);
        }
        return id;
    }
    public String fetchSmsPermission() {
        // get SMS permission response from SharedPreferences
        return sharedPreferences.getString("sms_send", null);
    }
    public void saveSmsPermission(String smsPermission) {  // saves as "allowed" or "denied"
        // save SMS permission response to SharedPreferences
        SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.putString("sms_send", smsPermission);  // save smsPermission as "sms_send" to fetch later
        editor.apply();
    }
    public Long fetchId() {
        id = null;
        try {
            // set id to the Long "user_id" in SavedPreferences
            id = sharedPreferences.getLong("user_id", -1L);
        } catch (Exception e) {
            Log.e("UserRepository: retrieveId: ", "getLong call: " + e);
        }
        return id;
    }
    public void saveId(Long id) {
        // save user id to SharedPreferences
        if (id == null) return;  // avoid null pointer exception (id.getValue() may be null
        try {
            SharedPreferences.Editor editor = sharedPreferences.edit();
            editor.putLong("user_id", id);  // save Long id value as "user_id"
            editor.apply();
        } catch (Exception e) {
            Log.e("UserRepository: saveId: ", "putLong call: " + e);
        }
    }
//==================================================================================================
//  TODO: Account Login and Password Security
//==================================================================================================
//  TODO: Input Validation (username and password rules)
//==================================================================================================
//  TODO: consider OAuth for authentication (maybe in a Service Layer / Authentication Manager)
// When user logs in:
// 0. search for existing username in database
//  (if not found, "username not found" + failCount++)
// 1. retrieve salt and hash for user from database
// 2. concatenate salt with password entered
// 3. hash concatenated string with SHA-256 or better algorithm
// 4. compare result with stored hash
// 5. if match, allow login; otherwise, deny login
// if failCount > 8, display error message "Too many failed attempts. Try in 5 minutes." and disable buttonSubmit for 5 minutes
// When user registers (or changes) password:
// 1. generate new salt (random string)
// 2. concatenate salt with password entered
// 3. hash concatenated string with SHA-256 or better algorithm
// 4. store salt and hashed password ("hash") in database
//==================================================================================================
}